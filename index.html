<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de Amor - Three.js</title>
    <!-- Carga de Three.js y OrbitControls para la interactividad -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Oculta barras de desplazamiento */
            background-color: #000000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 16px;
            text-align: center;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 10;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }
        .container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container" class="container"></div>
    <div id="info">¡5 Anillos de Amor! Gira y haz Zoom (Scroll) para explorar la Galaxia.</div>

    <script>
        // Variables globales de Three.js
        // La escena, la cámara y el renderizador son esenciales para Three.js
        let scene, camera, renderer, controls;
        let starfield; // Referencia al fondo de estrellas
        const orbitingElements = []; // Almacenará las palabras y corazones que orbitan

        // --- LISTA EXPANDIDA DE PALABRAS Y FRASES (50 en total) ---

        const ALL_TERMS = [
            // Apodos originales
            "Mi niña", "Mi cielo", "Mi vida", "Mi corazón", "Mi amorcito", "Mi ternura", "Bebita", "Preciosa", "Bonita", "Lindura", "Cariñito", "Encantadora", "Dulzura", "Tesoro", "Mi pequeña", "Cosita linda", "Mi luz", "Angelito", "Chiquita bella", "Mi florecita",
            // Frases originales
            "Te amo", "Te quiero", "Te adoro", "Te extraño", "Me encantas", "Eres todo para mí", "Eres lo más bonito de mi día", "Estoy loco por ti", "Me gustas muchísimo", "Eres mi lugar favorito", "Me haces bien", "Eres mi paz", "Eres mi persona", "Te necesito aquí", "Me traes loco",
            // Frases y apodos adicionales para más densidad
            "Mi estrella", "Reina", "Mi todo", "Muñequita", "Mi sol", "Cuento contigo", "Me completas", "Gracias por existir", "Eres mi motor", "Pienso en ti", "Contigo soy feliz", "Adoro tu sonrisa", "Sueño contigo", "Te elijo a ti", "Mi destino"
        ];
        
        // Distribución de las 50 palabras en CINCO anillos orbitales 
        const GALAXIA_DATA = [
            // Anillo 1 (El más cercano y rápido)
            { words: ALL_TERMS.slice(0, 8), color: "#FF00FF", radius: 40, speed: 0.005, heartInterval: 1 }, 
            // Anillo 2
            { words: ALL_TERMS.slice(8, 18), color: "#FF69B4", radius: 70, speed: 0.004, heartInterval: 2 }, 
            // Anillo 3 (Central)
            { words: ALL_TERMS.slice(18, 30), color: "#00FFFF", radius: 110, speed: 0.003, heartInterval: 3 }, 
            // Anillo 4
            { words: ALL_TERMS.slice(30, 40), color: "#FFD700", radius: 150, speed: 0.002, heartInterval: 2 },
            // Anillo 5 (El más lejano y lento)
            { words: ALL_TERMS.slice(40, 50), color: "#FFFFFF", radius: 190, speed: 0.001, heartInterval: 3 },
        ];

        // --- Inicialización ---
        function init() {
            // 1. Escena
            scene = new THREE.Scene();

            // 2. Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250; 

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 4. Controles de Órbita
            // Permiten al usuario rotar y hacer zoom en la escena
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 20; 
            controls.maxDistance = 600;

            // 5. Luces (Ajustadas para el sol más grande y realista)
            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);

            // Luz puntual intensa para simular el brillo del sol
            const pointLight = new THREE.PointLight(0xFFFFFF, 20, 500); 
            scene.add(pointLight);

            // Crear todos los elementos
            createStarfield();
            createCentralSun(); // Sol más grande
            createRings(); // 5 Anillos de palabras y corazones

            // Manejar redimensionamiento
            window.addEventListener('resize', onWindowResize, false);
            
            // Iniciar el bucle de animación
            animate();
        }

        // --- Funciones de Creación de Elementos ---

        // Función para crear el fondo de estrellas (Partículas)
        function createStarfield() {
            const starCount = 10000;
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];

            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1,
                sizeAttenuation: true 
            });

            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        // Función para crear el Sol/Núcleo de la Galaxia (más grande y realista)
        function createCentralSun() {
            // Radio más grande y más segmentos para una esfera más suave
            const sunGeometry = new THREE.SphereGeometry(25, 64, 64); 

            // Material con luz propia para simular un sol ardiente
            const sunMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF8C00, 
                emissive: 0xFF4500, 
                shininess: 100
            });

            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.name = "CentralSun";
            scene.add(sun);

            // Efecto de resplandor (Flare)
            const flareTexture = createFlareTexture();
            const flareMaterial = new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xFFFF00, 
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flare = new THREE.Sprite(flareMaterial);
            flare.scale.set(120, 120, 1); 
            sun.add(flare); 
        }

        // Función auxiliar para generar la textura de resplandor (un degradado radial)
        function createFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }

        // Función para crear la textura de la palabra como Sprite (plano 2D siempre mirando a cámara)
        function createTextSprite(message, color = "#FFFFFF") {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `Bold ${fontSize}px Inter, sans-serif`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + 10;
            canvas.height = fontSize + 10;
            context.font = `Bold ${fontSize}px Inter, sans-serif`; 
            context.fillStyle = color;
            context.fillText(message, 5, fontSize - 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(canvas.width / 8, canvas.height / 8, 1);
            return sprite;
        }

        // Función para crear la textura del corazón como Sprite
        function createHeartSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const color = "#FF007F"; 
            context.fillStyle = color;
            context.shadowColor = color;
            context.shadowBlur = 5;

            // Dibujar un corazón usando Path
            context.beginPath();
            const x = 32;
            const y = 32;
            const size = 18;
            context.moveTo(x, y + size / 2);
            context.bezierCurveTo(x + size, y - size, x + size * 2, y + size / 2, x, y + size * 1.5);
            context.bezierCurveTo(x - size * 2, y + size / 2, x - size, y - size, x, y + size / 2);
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10, 10, 1);
            return sprite;
        }

        // Función principal para crear los CINCO anillos de palabras y corazones
        function createRings() {
            GALAXIA_DATA.forEach(ring => {
                const words = ring.words;
                // Calculamos el total de elementos (palabras + corazones) para distribuir uniformemente
                const totalElements = words.length + Math.floor(words.length / ring.heartInterval);
                let elementIndex = 0; 
                let wordCounter = 0; 

                for (let i = 0; i < totalElements; i++) {
                    let element;
                    // Lógica para alternar palabras y corazones
                    let isHeart = (i % (ring.heartInterval + 1) === ring.heartInterval); 

                    if (!isHeart && wordCounter < words.length) { 
                        // Es una palabra
                        element = createTextSprite(words[wordCounter], ring.color);
                        wordCounter++;
                    } else if (isHeart) {
                        // Es un corazón
                        element = createHeartSprite();
                    } else {
                        // Si nos quedamos sin palabras, terminamos este anillo
                        break; 
                    }

                    // Posicionar el elemento en el anillo (círculo 3D)
                    const angle = (elementIndex / totalElements) * Math.PI * 2;
                    element.position.x = Math.cos(angle) * ring.radius;
                    element.position.z = Math.sin(angle) * ring.radius;
                    element.position.y = (Math.random() - 0.5) * 8; // Dispersión en Y para profundidad

                    // Almacenar datos para el movimiento
                    element.userData = {
                        angle: angle,
                        radius: ring.radius,
                        speed: ring.speed,
                        isHeart: isHeart 
                    };

                    orbitingElements.push(element);
                    scene.add(element);
                    elementIndex++;
                }
            });
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            const sun = scene.getObjectByName("CentralSun");
            if (sun) {
                // Rotar el Sol central
                sun.rotation.y += 0.003;
                sun.rotation.x += 0.001;
            }

            // Mover los elementos orbitando
            orbitingElements.forEach(element => {
                const { radius, speed } = element.userData;

                // Incrementar el ángulo y calcular la nueva posición
                element.userData.angle += speed;
                element.position.x = Math.cos(element.userData.angle) * radius;
                element.position.z = Math.sin(element.userData.angle) * radius;

                // Animación de pulsación para los corazones
                if (element.userData.isHeart) {
                    const scaleFactor = 1 + Math.sin(Date.now() * 0.005) * 0.2; 
                    element.scale.set(10 * scaleFactor, 10 * scaleFactor, 1);
                }
                
                // Asegurar que las palabras siempre miren a la cámara
                element.rotation.y = camera.rotation.y;
            });


            // Actualizar controles y renderizar
            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Manejo de Eventos ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Iniciar la aplicación 3D al cargar la ventana
        window.onload = init;
    </script>
</body>
</html>
