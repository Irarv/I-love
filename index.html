<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de Amor - Three.js</title>
    <!-- Carga de Three.js y OrbitControls para la interactividad -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Oculta barras de desplazamiento */
            background-color: #000000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 16px;
            text-align: center;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 10;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }
        .container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container" class="container"></div>
    <!-- ¡IMPORTANTE! Solo un div con id="info" -->
    <div id="info">Esta galaxia está hecha de palabras, para ti mi vida. Gira y explora los 5 anillos.</div>

    <script>
        // Variables globales de Three.js
        let scene, camera, renderer, controls;
        let starfield; // Referencia al fondo de estrellas
        const orbitingElements = []; // Almacenará las palabras y corazones que orbitan

        // --- LISTA EXPANDIDA DE PALABRAS Y FRASES (50 en total) ---
        // ¡LISTA CORREGIDA SIN DUPLICADOS!
        const ALL_TERMS = [
            // Grupo 1: Apodos y nuevas frases íntimas (10 términos, índices 0-9)
            "Para ti mi vida", "Mi niña", "Mi cielo", "Mi corazón", "Mi amorcito", "Mi ternura", "Bebita", "Preciosa", "Bonita", "Lindura", 
            // Grupo 2: Frases de afecto profundas (10 términos, índices 10-19)
            "Cariñito", "Encantadora", "Dulzura", "Tesoro", "Mi pequeña", "Cosita linda", "Mi luz", "Angelito", "Chiquita bella", "Mi florecita",
            // Grupo 3: Sentimientos y dedicación (10 términos, índices 20-29)
            "Eres mi todo", "Te amo", "Te quiero", "Te adoro", "Te extraño", "Me encantas", "Eres lo más bonito de mi día", "Estoy loco por ti", "Me gustas muchísimo", "Eres mi lugar favorito", 
            // Grupo 4: Estado y conexión (10 términos, índices 30-39)
            "Me haces bien", "Eres mi paz", "Eres mi persona", "Te necesito aquí", "Me traes loco", "Mi estrella", "Reina", "Mi sol", "Cuento contigo", "Me completas",
            // Grupo 5: Futuro y gratitud (10 términos, índices 40-49)
            "Gracias por existir", "Eres mi motor", "Pienso en ti", "Contigo soy feliz", "Adoro tu sonrisa", "Sueño contigo", "Te elijo a ti", "Mi destino", "Por siempre", "Junto a ti"
        ];
        
        // Distribución de las 50 palabras en CINCO anillos orbitales 
        const GALAXIA_DATA = [
            // Anillo 1 (0 a 10)
            { words: ALL_TERMS.slice(0, 10), color: "#FF00FF", radius: 40, speed: 0.006, heartInterval: 1 }, 
            // Anillo 2 (10 a 20)
            { words: ALL_TERMS.slice(10, 20), color: "#FF69B4", radius: 70, speed: 0.005, heartInterval: 2 }, 
            // Anillo 3 (20 a 30)
            { words: ALL_TERMS.slice(20, 30), color: "#00FFFF", radius: 110, speed: 0.004, heartInterval: 3 }, 
            // Anillo 4 (30 a 40)
            { words: ALL_TERMS.slice(30, 40), color: "#FFD700", radius: 150, speed: 0.003, heartInterval: 2 },
            // Anillo 5 (40 a 50)
            { words: ALL_TERMS.slice(40, 50), color: "#FFFFFF", radius: 190, speed: 0.002, heartInterval: 3 },
        ];

        // --- Inicialización ---
        function init() {
            // 1. Escena
            scene = new THREE.Scene();

            // 2. Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250; 

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 4. Controles de Órbita
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.minDistance = 20; 
            controls.maxDistance = 600;

            // 5. Luces 
            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);

            // Luz puntual intensa para el núcleo galáctico
            const pointLight = new THREE.PointLight(0xFFFFFF, 30, 500); // Intensidad aumentada
            scene.add(pointLight);

            // Crear todos los elementos
            createStarfield();
            createGalacticCore(); // Núcleo de Vía Láctea denso
            createRings(); // 5 Anillos de palabras y corazones

            // Manejar redimensionamiento
            window.addEventListener('resize', onWindowResize, false);
            
            // Iniciar el bucle de animación
            animate();
        }

        // --- Funciones de Creación de Elementos ---

        // Función para crear el fondo de estrellas (Partículas) - Ahora 10 veces más denso
        function createStarfield() {
            const starCount = 100000; // 100,000 estrellas para mayor realismo
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];

            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 2500; // Rango más amplio
                const y = (Math.random() - 0.5) * 2500;
                const z = (Math.random() - 0.5) * 2500;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1.5, // Ligeramente más grandes
                sizeAttenuation: true 
            });

            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        // Función para crear el Núcleo Galáctico (Vía Láctea) - Densidad aumentada a 50,000 partículas
        function createGalacticCore() {
            const coreRadius = 50; 
            const coreHeight = 8; // Ligeramente más grueso
            const coreParticles = 50000; // ¡50,000 partículas!
            
            const coreGeometry = new THREE.BufferGeometry();
            const coreVertices = [];
            const colors = [];
            // Ajuste de colores para un efecto de nebulosa más intenso
            const colorA = new THREE.Color(0xFF00AA); // Magenta intenso
            const colorB = new THREE.Color(0x00AAFF); // Azul eléctrico

            for (let i = 0; i < coreParticles; i++) {
                // Generación de partículas más concentrada al centro
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * coreRadius * Math.random(); // Distorsión de radio para concentrar el centro
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = (Math.random() - 0.5) * coreHeight; 
                
                coreVertices.push(x, y, z);
                
                // Asignar un color interpolado para un efecto de remolino o degradado
                const color = colorA.clone().lerp(colorB, radius / coreRadius);
                colors.push(color.r, color.g, color.b);
            }
            
            coreGeometry.setAttribute('position', new THREE.Float32BufferAttribute(coreVertices, 3));
            coreGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const coreMaterial = new THREE.PointsMaterial({
                size: 1.2,
                sizeAttenuation: true,
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.9 
            });

            const core = new THREE.Points(coreGeometry, coreMaterial);
            core.name = "GalacticCore";
            scene.add(core);

            // Añadir un brillo central (flare) que rota con el núcleo
            const flareTexture = createFlareTexture();
            const flareMaterial = new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xFFD700, // Dorado para el brillo central
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flare = new THREE.Sprite(flareMaterial);
            flare.scale.set(150, 150, 1); 
            core.add(flare); 
        }

        // Función auxiliar para generar la textura de resplandor (un degradado radial)
        function createFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }

        // Función para crear la textura de la palabra como Sprite (plano 2D siempre mirando a cámara)
        function createTextSprite(message, color = "#FFFFFF") {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `Bold ${fontSize}px Inter, sans-serif`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + 10;
            canvas.height = fontSize + 10;
            context.font = `Bold ${fontSize}px Inter, sans-serif`; 
            context.fillStyle = color;
            context.fillText(message, 5, fontSize - 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(canvas.width / 8, canvas.height / 8, 1);
            return sprite;
        }

        // Función para crear la textura del corazón como Sprite
        function createHeartSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const color = "#FF007F"; 
            context.fillStyle = color;
            context.shadowColor = color;
            context.shadowBlur = 5;

            // Dibujar un corazón usando Path
            context.beginPath();
            const x = 32;
            const y = 32;
            const size = 18;
            context.moveTo(x, y + size / 2);
            context.bezierCurveTo(x + size, y - size, x + size * 2, y + size / 2, x, y + size * 1.5);
            context.bezierCurveTo(x - size * 2, y + size / 2, x - size, y - size, x, y + size / 2);
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10, 10, 1);
            return sprite;
        }

        // Función principal para crear los CINCO anillos de palabras y corazones
        function createRings() {
            GALAXIA_DATA.forEach(ring => {
                const words = ring.words;
                // Calculamos el total de elementos (palabras + corazones) para distribuir uniformemente
                const totalElements = words.length + Math.floor(words.length / ring.heartInterval);
                let elementIndex = 0; 
                let wordCounter = 0; 

                for (let i = 0; i < totalElements; i++) {
                    let element;
                    // Lógica para alternar palabras y corazones
                    let isHeart = (i % (ring.heartInterval + 1) === ring.heartInterval); 

                    if (!isHeart && wordCounter < words.length) { 
                        // Es una palabra
                        element = createTextSprite(words[wordCounter], ring.color);
                        wordCounter++;
                        // Almacenar el tamaño original de la palabra para el efecto de pulso
                        element.userData.originalScale = element.scale.clone();
                    } else if (isHeart) {
                        // Es un corazón
                        element = createHeartSprite();
                    } else {
                        // Si nos quedamos sin palabras, terminamos este anillo
                        break; 
                    }

                    // Posicionar el elemento en el anillo (círculo 3D)
                    const angle = (elementIndex / totalElements) * Math.PI * 2;
                    element.position.x = Math.cos(angle) * ring.radius;
                    element.position.z = Math.sin(angle) * ring.radius;
                    element.position.y = (Math.random() - 0.5) * 8; // Dispersión en Y para profundidad

                    // Almacenar datos para el movimiento
                    element.userData = {
                        ...element.userData, // Mantener originalScale si existe
                        angle: angle,
                        radius: ring.radius,
                        speed: ring.speed,
                        isHeart: isHeart 
                    };

                    orbitingElements.push(element);
                    scene.add(element);
                    elementIndex++;
                }
            });
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            // Obtenemos el Núcleo Galáctico
            const core = scene.getObjectByName("GalacticCore");
            const time = Date.now() * 0.001; // Tiempo en segundos para animaciones
            if (core) {
                // Rotar el Núcleo Galáctico (simulando el giro de la Vía Láctea)
                core.rotation.y += 0.005; 
                core.rotation.x = Math.sin(time * 0.1) * 0.1; 
            }

            // Aplicar efecto de Parallax al fondo de estrellas
            if (starfield) {
                // Mueve la rotación de las estrellas ligeramente opuesta a la cámara para el efecto
                starfield.rotation.x = camera.rotation.x * 0.1;
                starfield.rotation.y = camera.rotation.y * 0.1;
            }

            // Mover los elementos orbitando
            orbitingElements.forEach(element => {
                const { radius, speed, isHeart, originalScale } = element.userData;

                // Incrementar el ángulo y calcular la nueva posición
                element.userData.angle += speed;
                element.position.x = Math.cos(element.userData.angle) * radius;
                element.position.z = Math.sin(element.userData.angle) * radius;

                // Rotación de la palabra sobre su eje Z
                if (!isHeart) {
                    element.rotation.z = Math.sin(time * 2 + radius * 0.1) * 0.1;
                }
                
                // Animación de pulsación para todos los elementos (más sutil en palabras)
                if (isHeart) {
                    // Pulsación más fuerte para el corazón
                    const scaleFactor = 1 + Math.sin(time * 5) * 0.2; 
                    element.scale.set(10 * scaleFactor, 10 * scaleFactor, 1);
                } else if (originalScale) {
                     // Pulsación sutil para la palabra
                    const pulse = 1 + Math.sin(time * 3 + radius) * 0.05;
                    element.scale.copy(originalScale).multiplyScalar(pulse);
                }
                
                // Asegurar que las palabras y corazones siempre miren a la cámara
                element.lookAt(camera.position); 
            });


            // Actualizar controles y renderizar
            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Manejo de Eventos ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Iniciar la aplicación 3D al cargar la ventana
        window.onload = init;
    </script>
</body>
</html>
