<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de Amor - Three.js</title>
    <!-- Carga de Three.js y OrbitControls para la interactividad -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Nota: En este entorno, a veces OrbitControls debe cargarse desde un CDN o estar incluido. Lo incluiré aquí. -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Oculta barras de desplazamiento */
            background-color: #000000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 16px;
            text-align: center;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 10;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container" class="container"></div>
    <div id="info">Gira y haz Zoom (Scroll) para explorar la Galaxia del Amor.</div>

    <script>
        // Variables globales de Three.js
        let scene, camera, renderer, controls;
        let starfield;
        const orbitingElements = []; // Almacenará las palabras y corazones

        // Configuración de la Galaxia
        const GALAXIA_DATA = [
            { text: "Amor Eterno", color: "#FF69B4", radius: 50, speed: 0.005, count: 5 },
            { text: "Felicidad", color: "#00FFFF", radius: 80, speed: 0.003, count: 8 },
            { text: "Siempre Juntos", color: "#FFFFFF", radius: 110, speed: 0.002, count: 7 },
        ];

        // --- Inicialización ---
        function init() {
            // 1. Escena
            scene = new THREE.Scene();

            // 2. Cámara
            // Parámetros: FOV, Aspect Ratio, Near, Far
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 4. Controles de Órbita (Permite la interacción de rotar y zoom)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Efecto de inercia
            controls.dampingFactor = 0.05;
            controls.minDistance = 5; // Limitar el zoom
            controls.maxDistance = 500;

            // 5. Luces (Necesarias para el Sol central)
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // Luz suave
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xFFFFFF, 10, 500); // Luz del Sol
            scene.add(pointLight);

            // Crear todos los elementos de la Galaxia
            createStarfield();
            createCentralSun();
            createRings();

            // Manejar redimensionamiento
            window.addEventListener('resize', onWindowResize, false);

            // Iniciar el bucle de animación
            animate();
        }

        // --- Funciones de Creación de Elementos ---

        // Función para crear el fondo de estrellas (Partículas)
        function createStarfield() {
            const starCount = 10000;
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];

            for (let i = 0; i < starCount; i++) {
                // Genera coordenadas aleatorias en un cubo grande
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            // Material para las estrellas (pequeños puntos blancos)
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1,
                sizeAttenuation: true // Hace que se vean más pequeñas cuanto más lejos están
            });

            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        // Función para crear el Sol/Núcleo de la Galaxia (esfera giratoria)
        function createCentralSun() {
            const sunGeometry = new THREE.SphereGeometry(15, 32, 32);

            // Material que simula un sol brillante o un núcleo galáctico
            const sunMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF8C00, // Naranja fuerte
                emissive: 0xFF4500, // Emite luz roja/naranja (brillo interno)
                shininess: 100
            });

            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.name = "CentralSun";
            scene.add(sun);

            // Añadir un brillo extra usando un Sprite para el efecto de resplandor
            const flareTexture = createFlareTexture();
            const flareMaterial = new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xFFFF00, // Amarillo brillante
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flare = new THREE.Sprite(flareMaterial);
            flare.scale.set(60, 60, 1);
            sun.add(flare); // Añadir el flare como hijo del Sol
        }

        // Función para crear la textura de resplandor
        function createFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }

        // Función para crear la textura de la palabra (como Sprite)
        function createTextSprite(message, color = "#FFFFFF") {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `Bold ${fontSize}px Inter, sans-serif`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            // Ajustar el tamaño del canvas para el texto
            canvas.width = textWidth + 10;
            canvas.height = fontSize + 10;
            context.font = `Bold ${fontSize}px Inter, sans-serif`; // Reset font after resize
            context.fillStyle = color;
            context.fillText(message, 5, fontSize - 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            // Ajustar escala para que se vea bien en 3D
            sprite.scale.set(canvas.width / 8, canvas.height / 8, 1);
            return sprite;
        }

        // Función para crear la textura del corazón
        function createHeartSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const color = "#FF007F"; // Rosa intenso
            context.fillStyle = color;
            context.shadowColor = color;
            context.shadowBlur = 5;

            // Dibujar un corazón usando Path
            context.beginPath();
            const x = 32;
            const y = 32;
            const size = 18;
            context.moveTo(x, y + size / 2);
            context.bezierCurveTo(x + size, y - size, x + size * 2, y + size / 2, x, y + size * 1.5);
            context.bezierCurveTo(x - size * 2, y + size / 2, x - size, y - size, x, y + size / 2);
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: new THREE.Color(color)
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10, 10, 1);
            return sprite;
        }

        // Función principal para crear los anillos de palabras y corazones
        function createRings() {
            GALAXIA_DATA.forEach(ring => {
                // Repetir el texto/corazón varias veces en el anillo
                for (let i = 0; i < ring.count; i++) {
                    let element;
                    if (i % 2 === 0) { // Alternar palabras y corazones (si es posible)
                        element = createTextSprite(ring.text, ring.color);
                    } else {
                        element = createHeartSprite();
                    }

                    // Posicionar el elemento en un círculo plano (anillo)
                    const angle = (i / ring.count) * Math.PI * 2;
                    element.position.x = Math.cos(angle) * ring.radius;
                    element.position.z = Math.sin(angle) * ring.radius;
                    element.position.y = (Math.random() - 0.5) * 5; // Ligeramente disperso en Y

                    // Almacenar el elemento con sus propiedades de órbita
                    element.userData = {
                        angle: angle,
                        radius: ring.radius,
                        speed: ring.speed,
                        isHeart: i % 2 !== 0
                    };

                    orbitingElements.push(element);
                    scene.add(element);
                }
            });
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            const sun = scene.getObjectByName("CentralSun");
            if (sun) {
                // Rotar el Sol central
                sun.rotation.y += 0.003;
                sun.rotation.x += 0.001;
            }

            // Mover los elementos orbitando
            orbitingElements.forEach(element => {
                const { angle, radius, speed } = element.userData;

                // Incrementar el ángulo
                element.userData.angle += speed;

                // Calcular la nueva posición en el anillo
                element.position.x = Math.cos(element.userData.angle) * radius;
                element.position.z = Math.sin(element.userData.angle) * radius;

                // Animación de escala/pulsación para los corazones
                if (element.userData.isHeart) {
                    const scaleFactor = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                    element.scale.set(10 * scaleFactor, 10 * scaleFactor, 1);
                }
            });


            // Actualizar controles y renderizar
            controls.update(); // Necesario para OrbitControls con damping
            renderer.render(scene, camera);
        }

        // --- Manejo de Eventos ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Iniciar la aplicación 3D una vez que la ventana esté completamente cargada
        window.onload = init;
    </script>
</body>
</html>
